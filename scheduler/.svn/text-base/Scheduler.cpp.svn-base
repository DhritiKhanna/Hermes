/*
 * Copyright (c) 2008-2009
 *
 * School of Computing, University of Utah,
 * Salt Lake City, UT 84112, USA
 *
 * and the Gauss Group
 * http://www.cs.utah.edu/formal_verification
 *
 * See LICENSE for licensing information
 */

/*
 * ISP: MPI Dynamic Verification Tool
 *
 * File:        Scheduler.cpp
 * Description: Scheduler that implements the process scheduling
 * Contact:     isp-dev@cs.utah.edu
 */

#include "Scheduler.hpp"
#include <sys/types.h>
#ifndef WIN32
#include <sys/select.h>
#include <sys/time.h>
#endif
#include <fstream>
#include <sstream>
#include <vector>
/* == fprs begin == */
#include <ctime>
/* == fprs end == */
#include "InterleavingTree.hpp"
/* == fprs begin == */
#define ISP_START_SAMPLING 2
#define ISP_END_SAMPLING 3
/* == fprs end == */

#include "Mo.hpp"
#include "Wu.hpp"

#ifdef _MSC_VER
#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
#endif

#include <cstdlib>


Scheduler * Scheduler::_instance = NULL;
/*
 * Initialize network variables.
 */
std::string Scheduler::_num_procs = "";
std::string Scheduler::_fname = "";
std::vector<std::string> Scheduler::_fargs = std::vector<std::string>();
std::string Scheduler::_port = "";
std::ofstream Scheduler::_logfile;
std::stringstream Scheduler::_mismatchLog;//CGD
std::string Scheduler::_server = "";
bool Scheduler::_send_block = false;
bool Scheduler::_mpicalls = false;
bool Scheduler::_verbose = false;
bool Scheduler::_quiet = false;
bool Scheduler::_unix_sockets = false;
int  Scheduler::_report_progress = 0;
bool Scheduler::_fib = false;
bool Scheduler::_openmp = false;
bool Scheduler::_env_only = false;
bool Scheduler::_probed = false;
bool Scheduler::_batch_mode = false;
int  Scheduler::interleavings = 0;
te_Exp_Mode  Scheduler::_explore_mode = EXP_MODE_ALL;
int  Scheduler::_explore_some = 0;
std::vector<int>* Scheduler::_explore_all = NULL;
std::vector<int>* Scheduler::_explore_random = NULL;
std::vector<int>* Scheduler::_explore_left_most = NULL;
bool Scheduler::_stop_at_deadlock = false;
bool Scheduler::_just_dead_lock = false;
bool Scheduler::_deadlock_found = false;
bool Scheduler::_param_set = false;
int  Scheduler::_errorno = 0;
bool Scheduler::_debug = false;
bool Scheduler::_no_ample_set_fix = false;
unsigned Scheduler::_bound = 0;
bool Scheduler::_limit_output = false;
/* == fprs start == */
bool Scheduler::_fprs;
/* == fprs end == */

fd_set Scheduler::_fds;
SOCKET Scheduler::_lfd = 0;
std::map <SOCKET, int> Scheduler::_fd_id_map;

/*
 * Queues maintained by the Scheduler
 */

std::vector <MpiProc *> Scheduler::_runQ;
Node *Scheduler::root = NULL;

/////////////////////////////////////////////////////
///                                               /// 
///    HELPER FUNCTIONS Implementation            ///  
////////////////////////////////////////////////////

// std::set<int> getImmediateAncestorList (Node *ncurr, int _pid, std::vector<int> &_list) {
//   std::set<int>  _ancestor;
//   std::vector<int> _tancestor;
//   std::vector<int>::iterator _lit, _litend;
//   _litend = _list.end();
  
//   for(_lit = _list.begin(); _lit != _litend; _lit++) {
//     Transition *_t = ncurr->GetTransition(_pid, *_lit);
//     _tancestor = _t->get_ancestors();   
//     _ancestor.insert(_tancestor.begin(), _tancestor.end());
//   }
//   //std::cout << "Printing Ancestor List : [";
//   //std::vector<int>::iterator sit, sit_end;
//   //for(sit = _tancestor.begin(); sit != _tancestor.end(); sit++) {
//   //  std::cout << *sit << ",";   
//   //}
//   //std::cout << "]\n";
//   return _ancestor;
// }

// std::set<int> getAllAncestorList(Node *ncurr, CB c) {
//   std::set<int> _allancestors, _iancestors;
//   std::vector<int> _ilist;
//   _ilist.push_back(c._index);
//   unsigned int size;
    
//   do {
//     size = _allancestors.size();
//     _iancestors = getImmediateAncestorList(ncurr, c._pid, _ilist);
//     std::set<int>::iterator it, it_end;
//     it_end = _iancestors.end();
//     _ilist.clear();
//     for(it = _iancestors.begin(); it != it_end; it++) {
//       _allancestors.insert(*it);
//       _ilist.push_back(*it);
//     }

//   }while(size != _allancestors.size());


//   // debug print
//   //
//   //std::set<int>::iterator it, itE;
//   //itE = _allancestors.end();
//   //std::cout << "All Ancestors of " << c << ": [ ";
//   //for(it = _allancestors.begin(); it != itE; it++) {
//   //  std::cout << *it << " " ;
//   //}

//   //std::cout << "]\n";
//   return _allancestors;
// }

// std::set<int> getImmediateDescendantList (Node *ncurr, int _pid, std::vector<int> &_list)
// {
//   std::set<int> _descendant;
  
//   std::vector<int>::iterator _it, _itend;
//   _itend = _list.end();
  
//   //std::cout << "In ImmediateDesc\n"<<"pid:" <<_pid <<std::endl ;
  
//   for(_it = _list.begin(); _it != _itend; _it++) {
//     Transition *_t = ncurr->GetTransition(_pid, *_it);
//     std::vector<CB> _tdesc = _t->get_intra_cb();
//     for(std::vector<CB>::iterator it = _tdesc.begin();
// 	it != _tdesc.end(); it++){
//       _descendant.insert((*it)._index);	  
//     }    
//   }  
//   return _descendant;
// }

// std::set<int> getAllDescendantList (Node *ncurr, CB c)
// {
//   std::set<int> _alldescendants, _idescendants;
//   std::vector<int> _ilist;
//   _ilist.push_back(c._index);
//   unsigned int size;

//   do {
//     size = _alldescendants.size();
//     _idescendants = getImmediateDescendantList(ncurr, c._pid, _ilist);
//     std::set<int>::iterator it, it_end;
//     it_end = _idescendants.end();
//     _ilist.clear();
//     for(it = _idescendants.begin(); it != it_end; it++) {
//       _alldescendants.insert(*it);
//       _ilist.push_back(*it);
//     }
//   }while(size != _alldescendants.size());

//   // debug print
//   //
//   //std::set<int>::iterator it, itE;
//   //itE = _alldescendants.end();
//   //std::cout << "All Descendants of " << c << ": [ ";
//   //for(it = _alldescendants.begin(); it != itE; it++) {
//   //  std::cout << *it << " " ;
//   //}

//   //std::cout << "]\n";

   
//   return _alldescendants;
// }

// /////////////////////////////////////////////////////
// ///                                               /// 
// ///    WfR Implementation                         ///  
// ////////////////////////////////////////////////////

// extern bool is_eql(std::pair<CB, CB> p1, std::pair<CB, CB> p2);


// WfR::WfR() {

// }

// std::ostream & operator<<(std::ostream &os, const WfR &c)
// {
//   std::vector < std::pair <CB, CB> >::const_iterator it, it_end;
//   //it_end = wfr.end();
//   os << "WfR["<< std::endl;
//   for (it = c.wfr.begin(); it != c.wfr.end(); it ++ ){
//     os << (*it).first << "," << (*it).second <<std::endl;
//   }
//   os <<"]\n";
 
//   return os;
// }

// WfRVecIterator WfR::isPresent(std::pair<CB, CB>  & p)
// {
//   CB c1 = p.first;
//   CB c2 = p.second;
  
//   if(c1._pid == -1 || c2._pid == -1 ||
//      c1._index == -1 || c2._index == -1) 
//     assert(false);

//   WfRVecIterator it, it_end;
//   //long i = 0;
  
//   it_end = wfr.end();
  
//   for(it = wfr.begin(); it != it_end; it++)
//     if( is_eql(p, (*it)) )
//       return it;

//   return it; 
// }


// // not necessary
// void WfR::removeWfEdge(std::pair<CB, CB> p)
// {
//   WfRVecIterator  i = isPresent(p);

//   if(i != wfr.end())
//     wfr.erase(i);
// }

// void WfR::addWfEdge(std::pair<CB, CB> p)
// {
//     WfRVecIterator it = isPresent(p);

//     if(it == wfr.end())
//       wfr.push_back(p);
// }

// void WfR::addWfSet(CB cfrom, std::set <int> scb, int pid) {

//   std::set<int>::iterator it, it_end;
//   it_end = scb.end();

//   //std::cout << cfrom << " to aset: [ " ;
//   for(it = scb.begin(); it != it_end; it++) {
//     CB cto = *(new CB(pid, *it));
//     //std::cout << *it << " " ;
//     addWfEdge(std::pair<CB, CB>(cfrom, cto));
//   }
//   //std::cout << "]\n"; 
// }

// void WfR::transitiveClosure()
// {
  
//   WfRVecIterator _vit, _vitend, _vit1, _vit2;
 
//   // iterate for each a--->b

//   // std::cout << "Addition of Edge Stage\n":

//   for(_vit = wfr.begin(); _vit != wfr.end(); _vit++){
//     CB _wfrom = (*_vit).first; //a
//     CB _wto = (*_vit).second;  // b
 
//     //    std::cout << "a--->b:" << _wfrom <<"--->"<<_wto <<std::endl;

//     // iterate over each c--->d
//     // add a--->d iff
//     // 1) c is Ancs*(b) 
//     // 2) a --> Desc*(d) does not exist

//     for(_vit1 = wfr.begin(); _vit1 != wfr.end(); _vit1++) {
//       CB _from = (*_vit1).first;  //c
//       CB _to = (*_vit1).second; // d
      
//       if(_from == _wto)
// 	addWfEdge(std::pair<CB,CB> (_wfrom, _to));
//       // std::cout << "c-->d:" << _from <<"--->"<<_to <<std::endl;
      

// 	// 1) check c.pid == b.pid and 
// 	// 2) c = Ancs*(b)
// 	// 3) d.pid != b.pid

//         // if(_from._pid == _wto._pid && _from._index <= _wto._index){ // (1) and (2) 
// 	//   if (_to._pid != _wfrom._pid ){
// 	//     //std::cout<<" added: " <<  _wfrom << _to <<std::endl;
// 	//     addWfEdge(std::pair<CB,CB> (_wfrom, _to));
// 	//   } 
// 	//   else
// 	//     ;// std::cout << "d's pid is same as a's pid" <<std::endl;
// 	// }
// 	// else
// 	//   ;//std::cout << "c's pid is same as a's pid OR c = Desc(b)" <<std::endl;
//     }
//     // std::cout << "================" <<std::endl;
//   }
  
// }
// std::set<int> WfR::find_k_op_ancestor_set(Node *ncurr, int _psrc, int _pdst, int difference) {
//   std::vector<Transition> tlist = ncurr->_tlist[_psrc]->_tlist;
//   std::vector<Transition>::iterator it, itend;
//   itend = tlist.end();  
//   Envelope *env;
//   int k = 0;
//   for(it = tlist.begin(); it != itend; it++) {
//     env = (*it).GetEnvelope();
//     if(env->isSendType() && env->dest == _pdst){
//       k++;
//       if(k == difference) break;
//     }
//   }
//   assert( it != itend);

//   CB _cb(_psrc, env->index);
//   std::vector<int> list;
//   list.push_back( _cb._index);
//   std::set<int> _idescendant = getImmediateAncestorList(ncurr, _psrc, list);
   
//   return _idescendant;  

// }

// std::set<int> WfR::find_first_op_ancestor_set (Node *ncurr, int psrc, int pdst) {
//   std::vector<Transition> tlist = ncurr->_tlist[psrc]->_tlist;

//   std::vector<Transition>::iterator it, itend;

//   itend = tlist.end();
//   Envelope *env;
//   // CB _cb;

//   for(it = tlist.begin(); it != itend; it++) {
//     env = (*it).GetEnvelope();
//     if(env->isSendType() && env->dest == pdst){
//       // _cb._pid = psrc;
//       // _cb._index = env->index;
//       //CeR
//       VecIterator cit = co_enabled_relation.isPresent(std::pair<CB, CB> (_cb,))
//       break;
//     }
//   }
//   assert(it != itend);
  
//   CB _cb(psrc, env->index);

//   std::vector<int> list;
//   list.push_back(_cb._index);
//   std::set<int> _iancestor = getImmediateAncestorList(ncurr, psrc, list);

//   return _iancestor;

// }

// void WfR::WfRConstructDet(Node *ncurr, Node *nlast) {
//   int _psrc = ncurr->curr_match_set.front()._pid; // sending process pid
//   int _pdst = ncurr->curr_match_set.back()._pid;  // recv process pid

  
//   //  std::cout<< "In WfRConstruct:\n";

//   /* get differential count between <Scurr, Rcurr> */
//   int _diff = ncurr->_countracker.getDiffCount(_psrc, _pdst);
//   int _ldiff = nlast->_countracker.getDiffCount(_psrc, _pdst);
//   //std::cout<< "Calculated the _diff:" << _diff << " and _ldiff:" <<_ldiff << std::endl;
//   std::vector<int> _list;
//   std::set<int> _aset;

//   // diff = 0
       
//   if(_diff == 0) {
//     // Scurr --> ImmAncs(Rcurr)
//     //std::cout << "diff = 0 for " << ncurr->curr_match_set.front() << "," << ncurr->curr_match_set.back() << std::endl;
//     //std::cout << "finding immediate ancestor for : " << ncurr->curr_match_set.back() << std::endl;
//     _list.push_back(ncurr->curr_match_set.back()._index);
//     // _list is Rcur index only
//     _aset = getImmediateAncestorList(ncurr, _pdst, _list);
//     std::set<int>::iterator _sit;
//     //std::cout << "aset for " << ncurr->curr_match_set.back() << "[ "; 
//     //for(_sit = _aset.begin(); _sit != _aset.end(); _sit++) {
//     //    std::cout << *_sit << " ";
//     //}
//     //std::cout <<" ]\n";
//     //std::cout.flush();
//     if(!_aset.empty())
//       addWfSet(ncurr->curr_match_set.front(), _aset, _pdst);
           
//     // Rcurr --> Ansc(Scurr) if
//     //  nlast.diff - ncurr.sndcnt + 1 < 0

//     // diff is 0
//     // add Rcurr -> ImmAncs(Scurr)
//     if(_ldiff == 0) {
//       _list.clear();
//       _list.push_back(ncurr->curr_match_set.front()._index);
//       _aset.clear();
//       _aset = getImmediateAncestorList(ncurr, _psrc, _list);
//       if(!_aset.empty())
// 	addWfSet(ncurr->curr_match_set.back(), _aset, _psrc);
//     }
//     else {
//       //
//       int difference = _ldiff - (ncurr->_countracker.getSendCount(_psrc, _pdst)-1); 
//       if(difference >= 0) {
// 	// iterate over _tlist[_psrc]
// 	// find first send that targets _pdst
// 	// if there is a valid ancestor to such a send, add Rcurr -> ImmAncs(found send)
// 	_aset.clear();
// 	_aset = find_first_op_ancestor_set(ncurr, _psrc, _pdst);

// 	if(!_aset.empty())  {
// 	  addWfSet(ncurr->curr_match_set.back(), _aset, _psrc); 
// 	}

//       }

//       else {
// 	// difference < 0
// 	// find the send indexed at |difference| from start
// 	// find the ancestor set of this send
// 	// add Rcurr --> comnputed ancestor set
// 	std::set<int> _aset = find_k_op_ancestor_set(ncurr, _psrc, _pdst, abs(difference));
// 	if(!_aset.empty()){
// 	  addWfSet(ncurr->curr_match_set.back(), _aset, _psrc);
// 	}
//       }   
//     }

//   }
//   else {
//     int difference = (_ldiff- _diff) - (ncurr->_countracker.getSendCount(_psrc, _pdst)-1); 
//     // add Scurr--> ancestor of first of CoI of Scurr
    
//     std::set<CB> coi = coenabledPtr->findCoEnabledImage(ncurr->curr_match_set.front());
//     CB firstcb = coenabledPtr->find_first_CoI(coi, _pdst);
//     _list.clear();
//     _list.push_back(firstcb._index);
//     _aset.clear();
//     _aset = getImmediateAncestorList(ncurr, _pdst, _list);
//     if(!_aset.empty())  {
//       addWfSet(ncurr->curr_match_set.front(), _aset, _pdst); 
//     }
	  
//     // for adding Rcurr --> Ancs(Scurr)
//     if(difference >= 0) {
//       // iterate over _tlist[_psrc]
//       // find first send that targets _pdst
//       // if there is a valid ancestor to such a send, add Rcurr -> ImmAncs(found send)
//       _aset.clear();
//       _aset = find_first_op_ancestor_set(ncurr, _psrc, _pdst);
	 
//       if(!_aset.empty())  {
// 	addWfSet(ncurr->curr_match_set.back(), _aset, _psrc); 
//       }

//     }
       
//     else {
//       // difference < 0
//       // find the send indexed at |difference| from start
//       // find the ancestor set of this send
//       // add Rcurr --> comnputed ancestor set
//       _aset.clear();
//       _aset = find_k_op_ancestor_set(ncurr, _psrc, _pdst, abs(difference));
//       if(!_aset.empty()){
// 	addWfSet(ncurr->curr_match_set.back(), _aset, _psrc);
//       }
//     }
       
//   }
// }

// void WfR::WfRConstructNonDet(Node *ncurr, Node *nlast) {
//   // precisely a copy of WfRConstructDet  
// }

// void WfR::WfRConstruct(ITree *itree) {
//   Node *ncurr, *nlast;
//   // get the last node of itree
//   nlast = itree->_slist[itree->_slist.size()-1];

//   std::vector<Node*>::iterator _slist_it, _slist_it_end;

//   _slist_it_end = itree->_slist.end();
//   int i = 0;
//   // iterate over the state vector for the current trace
//   for(_slist_it = itree->_slist.begin();
//       _slist_it != _slist_it_end; _slist_it++, ++i) {
//     ncurr = *(_slist_it);
    
//     Envelope *env = ncurr->GetTransition(ncurr->curr_match_set.back())->GetEnvelope();
//     //std::cout << *(ncurr->GetTransition(ncurr->curr_match_set.back()))<<std::endl;
//     //std::cout << i << std::endl;
//     if(ncurr->curr_match_set.size() == 2){
//       if(env->func_id == IRECV || env->func_id == RECV) {
// 	//std::cout<< "WfRCounstructDet called for Node with match \n"<<ncurr->curr_match_set.front()<<ncurr->curr_match_set.back()<<std::endl;
// 	WfRConstructDet(ncurr, nlast);
//       }
//     }
//   }     
// }

// std::pair<CB, CB> WfR::getLastWfR(std::pair<CB, CB> p)
// {
//   CB from = p.first;
//   CB to = p.second;
  
//   int src_pid = from._pid;
//   int dest_pid = to._pid;
  
//   WfRVecIterator _vit, _vitend;
  
//   _vitend = wfr.end();
//   // iterate for each a-->b
//   for(_vit = wfr.begin(); _vit != _vitend; _vit++){
//     CB _wfrom = (*_vit).first;
//     CB _wto = (*_vit).second;
//     if( _wfrom._pid == src_pid && _wto._pid == dest_pid){
//       if( _wfrom._index >= from._index 
// 	  && _wto._index >= to._index ){
// 	from = _wfrom;
// 	to = _wto;
//       }
//     }
//   }
//   return (std::pair<CB, CB>(from, to));
// }

// /////////////////////////////////////////////////////
// ///                                              /// 
// ///    CeR Implementation                        ///  
// ////////////////////////////////////////////////////


// CeR::CeR(){
  
// }

// std::ostream & operator<<(std::ostream &os, const CeR &c)
// {
//   std::vector < std::pair <CB, CB> >::const_iterator it, it_end;
//   // it_end = c.cer.end();
//   os << "CeR["<< std::endl;
//   for (it = c.cer.begin(); it != c.cer.end(); it ++ ){
//     os << (*it).first << "," << (*it).second <<std::endl;
//   }
//   os <<"]\n";
//   return os;
// }

// // find co-enabled image of c
// std::set <CB> CeR::findCoEnabledImage(CB c) {

//   // iterate cer
//   // if c is in cer[i].first or cer[i].second -> add cer[i].first or cer[i].second to set

//   std::set<CB> _coi;
//   std::vector <std::pair <CB, CB> > ::iterator it, it_end;
//   it_end = cer.end();

//   for(it = cer.begin(); it != it_end; it++) {
//     if(((*it).first == c)) {
//       _coi.insert((*it).second);
//     }
//     else if( (*it).second == c) {
//       _coi.insert((*it).first);
//     }
//   }

//   return _coi;
// }


// std::set<CB> CeR::findCoEnabledImageNotFrom(CB c, int from){
  
//   std::set<CB> _coi;
//   std::vector <std::pair <CB, CB> >::iterator it, it_end;
//   it_end = cer.end();
//   std::cout<< " In findCoEnabledImageNotFrom func with D1's entry: " << c << " and its CoI coming from other than " <<from <<std::endl;
//   for(it = cer.begin(); it != it_end; it++) {
//     if(((*it).first == c) && (*it).second._pid != from) {
//       _coi.insert((*it).second);
//     }
//    else if( (*it).second == c && (*it).first._pid != from) {
//       _coi.insert((*it).first);
//     }
//   }

//   return _coi;


// }

// // find first coi wrt pid
// // check at call site CB._index != MAX_TRANSITIONS
// CB CeR::find_first_CoI(std::set<CB> _coi, int pid) {
//   // iterate over list
//   // find small CB._index that is min
//   //
//   std::set<CB>::iterator it, it_end;
//   it_end = _coi.end();

//   CB _min(pid, MAX_T);
//   for(it = _coi.begin(); it != it_end; it++) {
//     if((*it)._pid == pid && (*it)._index < _min._index)
//       _min = *it;
//   }
//   return _min;
// }

// // find last coi wrt pid
// // check at call site CB._index != -1
// CB CeR::find_last_CoI(std::set<CB> _coi, int pid) {
 
//   // iterate over list
//   // find last _CB that is max
//   //
//   std::set<CB>::iterator it, it_end;
//   it_end = _coi.end();

//   CB _max(pid, -1);

//   for(it = _coi.begin(); it != it_end; it++) {
//     if((*it)._pid == pid && (*it)._index > _max._index)
//       _max = *it;
//   }

//   return _max;
// }

// CeRVecIterator CeR::isPresent(std::pair<CB, CB>  & p)
// {
//   CB c1 = p.first;
//   CB c2 = p.second;
  
//   if(c1._pid == -1 || c2._pid == -1 ||
//      c1._index == -1 || c2._index == -1) 
//     assert(false);

//   CeRVecIterator it, it_end;
//   //long i = 0;
  
//   it_end = cer.end();
  
//   for(it = cer.begin(); it != it_end; it++)
//     if( is_eql(p, (*it)) )
//       return it;

//   return it;
// }


// void CeR::removeCrEdge(std::pair <CB, CB> p){
//   CeRVecIterator i = isPresent(p);
   
//   if(i != cer.end())
//     cer.erase(i);
  
// }

// void CeR::addCrEdge (std::pair<CB, CB> p){
//   cer.push_back(p);

// }

// bool CeR::CeRupdate(std::pair <CB, CB> _pcer) {
//   CeRVecIterator it = isPresent(_pcer);

//   // return false, _pcer is present
//   if(it != cer.end())
//     return false;

//   cer.push_back(_pcer);
//   return true;
// }



// void CeR::CheckUpdateCeRAncs(Node* ncurr, int _psrc, int _pdst, std::set<int> _aset, int &_diff) {
    
//   std::set<int>::reverse_iterator _sit, _sitend;
//   _sitend = _aset.rend();

//   // reverse iterate on the set to find immediate ancestors
//   for(_sit = _aset.rbegin(); _sit != _sitend; _sit++) {
//     Transition *_t = ncurr->GetTransition(_pdst, *_sit);
//     CB _cb = *(new CB(_pdst, *_sit));
//     Envelope *env = _t->GetEnvelope(); // check if immediate ancestor targets pid(Scurr)
//     if(env->func_id == RECV || env->func_id == IRECV) {
//       if(!env->src_wildcard) {
// 	if(env->src == _psrc) {
// 	  if (CeRupdate(std::pair<CB, CB> (ncurr->curr_match_set.front(), _cb)))
// 	    _diff--;                       
// 	}
//       }
//       else {
// 	//std::cout << "adding cer edge\n";
// 	if (CeRupdate(std::pair<CB, CB> (ncurr->curr_match_set.front(), _cb))) {
// 	  _diff--;
// 	}
//       }
//       // when diff becomes 0 continue no further
//       if(_diff == 0)
// 	return;
//     }
//   }
// }

// void CeR::CheckUpdateCeRDesc(Node* ncurr, Node* nlast, int _psrc, int _pdst, std::set<int> _aset, int &_diff) {
    
//   std::set<int>::iterator _sit, _sitend;
//   _sitend = _aset.end();

//   // reverse iterate on the set to find immediate ancestors
//   for(_sit = _aset.begin(); _sit != _sitend; _sit++) {
//     Transition *_t = nlast->GetTransition(_pdst, *_sit);
//     CB _cb = *(new CB(_pdst, *_sit));
//     //std::cout << "_cb: " << _cb << std::endl;
//     //std::cout << "ncurr_curr_match_set : " << ncurr->curr_match_set.front() << std::endl;
//     Envelope *env = _t->GetEnvelope(); // check if immediate desc targets pid(Scurr)
//     if(env->func_id == RECV || env->func_id == IRECV) {
//       if(!env->src_wildcard) {
// 	if(env->src == _psrc) {
// 	  if (CeRupdate(std::pair<CB, CB> (ncurr->curr_match_set.front(), _cb)))
// 	    _diff--;                       
// 	}
//       }
//       else {
// 	//std::cout << "adding cer edge\n";
// 	if (CeRupdate(std::pair<CB, CB> (ncurr->curr_match_set.front(), _cb))) {
// 	  //   std::cout << "adding cer edge\n";
// 	  _diff--;
// 	}
//       }
            
//       // when diff becomes 0 continue no further
//       if(_diff == 0)
// 	return;
//     }
//   }
// }


// void CeR::CeRConstructAncs(Node* ncurr, Node* nlast) {
//   /*
//    * check if the current node match set  <Scurr, Rcurr>
//    */
//   if(ncurr->curr_match_set.size() == 2) {
//     int _psrc = ncurr->curr_match_set.front()._pid; // sending process pid
//     int _pdst = ncurr->curr_match_set.back()._pid;  // recv process pid
//     /* get differential count between <Scurr, Rcurr> */
//     int _diff = ncurr->_countracker.getDiffCount(_psrc, _pdst);
//     // debug print
//     //
//     //std::cout << "_diff : " << _diff << std::endl;
//     // add Rcurr index to ancestor
//     // _diff is reduced in CheckUpdateCeR
//     std::vector<int> _alist;
//     _alist.push_back(ncurr->curr_match_set.back()._index);
//     std::set<int> _aset;
//     // debug print
//     //
//     //_aset = getAllAncestorList(ncurr, ncurr->curr_match_set.back());
//     //std::cout << ncurr->curr_match_set.back() << std::endl;

//     while(_diff > 0) {
//       _aset = getImmediateAncestorList(ncurr, _pdst, _alist);
//       if(_aset.empty()) {
// 	// debug print
// 	//
// 	//std::cout << "breaking out from empty set\n";
// 	break;
//       }
//       CheckUpdateCeRAncs(ncurr, _psrc, _pdst, _aset, _diff);
//       //std::cout << "diff after CeR : " << _diff << std::endl;
//       //assert(_diff == 0);
//       _alist.clear();
//       for(std::set<int>::iterator it = _aset.begin(); 
// 	  it != _aset.end(); it++){
// 	_alist.push_back(*it);
//       }
//     }
//     assert(_diff == 0);
//   }
// }


// void CeR::CeRConstructDesc(Node* ncurr, Node* nlast) {
//   if(ncurr->curr_match_set.size()) {
//     int _psrc = ncurr->curr_match_set.front()._pid; // sending process pid
//     int _pdst = ncurr->curr_match_set.back()._pid;  // recv process pid
//     int _ldiff = nlast->_countracker.getDiffCount(_psrc, _pdst) - ncurr->_countracker.getDiffCount(_psrc, _pdst);
//     // debug print
//     //
//     //std::cout << "_ldiff : " << _ldiff << std::endl;
//     //nlast->_countracker.debugPrint();
//     //ncurr->_countracker.debugPrint();
//     //
//     //debug print
//     //
//     //std::set<int> _dset = getAllDescendantList(nlast, ncurr->curr_match_set.back());
//     //std::cout << ncurr->curr_match_set.back() << std::endl;
//     std::vector<int> _dlist;
//     _dlist.push_back(ncurr->curr_match_set.back()._index);
//     while(_ldiff) {
//       std::set<int> _dset = getImmediateDescendantList(nlast, _pdst, _dlist);
//       if(_dset.empty()) {
// 	break;
//       }
//       CheckUpdateCeRDesc(ncurr, nlast, _psrc, _pdst, _dset, _ldiff);
//       //assert(_ldiff == 0);
//       _dlist.clear();
//       for(std::set<int>::iterator it = _dset.begin(); 
// 	  it != _dset.end(); it++){
// 	_dlist.push_back(*it);                
//       }
//     }
//     assert(_ldiff == 0);
//   }
// }




// void CeR::CeRConstruct(ITree *itree) {

//   Node *nlast, *ncurr;

//   // get the last node of itree
//   nlast = itree->_slist[itree->_slist.size()-1];

//   std::vector<Node*>::iterator _slist_it, _slist_it_end;

//   _slist_it_end = itree->_slist.end();

//   // iterate over the state vector for the current trace
//   for(_slist_it = itree->_slist.begin();
//       _slist_it != _slist_it_end; _slist_it++) {
//     ncurr = *(_slist_it);
//     // debug print
//     //ncurr->_countracker.debugPrint();

//     CeRConstructAncs(ncurr, nlast);
//     CeRConstructDesc(ncurr, nlast);
//   }
// }

// end of svs addition
//

/////////////////////////////////////////////////////
///                                              /// 
///       Scheduler Implementation               ///  
////////////////////////////////////////////////////

/*
 * begin CoE modification
 * svs, sriram
 */

// bool Scheduler::SearchAndRemoveCeR(std::set<int> _desc_star, std::set<int> _ancs_star, CB _wfrom, CB _wto)
// {
//     bool flag = false;
//     Node *nlast = it->_slist[it->_slist.size()-1];
//     std::set<int>::iterator _dit, _dit_end;
//     _dit_end = _desc_star.end();
//     CeRVecIterator _cit, _citend, _present;
//     _citend = coenabled_relation.cer.end();
//     for(_dit = _desc_star.begin(); _dit != _dit_end; _dit++) {
//         CB _c(_wfrom._pid, *_dit);
//         Envelope *env = nlast->GetTransition(_c)->GetEnvelope();
//         if(env->isSendType() && env->dest == _wto._pid) {
//             for(_cit= coenabled_relation.cer.begin(); _cit != _citend; _cit++) {
//                 CB _cfrom, _cto;
//                 _cfrom = (*_cit).first;
//                 _cto = (*_cit).second;

//                 if( (_cfrom == _c) && (_cto._pid == _wto._pid && _cto._index <= _wto._index) ) { //condition to remove CeR edge
//                     coenabled_relation.removeCrEdge(std::pair<CB, CB> (_cfrom, _cto));
//                     flag = true;
//                 }
//             }
//         }


//     }

//     _dit_end = _ancs_star.end();
//     for(_dit = _ancs_star.begin(); _dit != _dit_end; _dit++) {
//         CB _c(_wto._pid, *_dit);
//         Envelope *env = nlast->GetTransition(_c)->GetEnvelope();
//         if(env->isSendType() && env->dest == _wfrom._pid) {
//             for(_cit= coenabled_relation.cer.begin(); _cit != _citend; _cit++) {
//                 CB _cfrom, _cto;
//                 _cfrom = (*_cit).first;
//                  _cto = (*_cit).second;
//                  //std::cout << "CeR CB : [ " << _cfrom << ", " << _cto << "]" << std::endl;

//                 if( (_cfrom == _c) && (_cto._pid == _wfrom._pid && _cto._index >= _wfrom._index) ) { //condition to remove CeR edge
//                     coenabled_relation.removeCrEdge(std::pair<CB, CB> (_cfrom, _cto));
//                     flag = true;
//                 }
//             }
//         }
//     }

//     return flag;
// }

// bool Scheduler::ApplyRefineRuleOne() {
//     /*
//      * Algorithm:
//      * for each wfr a->b
//      *  let desc* = desc(a) U a
//      *  let ancs* = ancs(b) U b
//      *  for each op in desc* 
//      *      for each p in CeR <CB, CB>
//      *          if p.first is S(p(b)) && p.second is in ancs*
//      *              remove p
//      */

//      WfRVecIterator wit, witend;
//      bool flag = false;

//      witend = waitfor_relation.wfr.end();

//      for(wit = waitfor_relation.wfr.begin(); wit != witend; wit++) {
//          CB _wfrom, _wto;
//          _wfrom = (*wit).first; // a
//          _wto = (*wit).second;  // b

//          Node* _nlast = it->_slist[it->_slist.size()-1];
//          //std::cout << "Node : " << (*_nlast).GetLevel() << std::endl;
//          //std::cout << "Wait-for : " << _wfrom << ", " << _wto << std::endl;
        
//          std::set<int>  _alldesc = getAllDescendantList(_nlast, _wfrom);
//          _alldesc.insert(_wfrom._index);    // desc*

//          std::set<int>  _allancs = getAllAncestorList(_nlast, _wto);
//          _allancs.insert(_wto._index);    // ancs*

//          flag = SearchAndRemoveCeR(_alldesc, _allancs, _wfrom, _wto);
//      }

//      return flag;
// }



// ///////////////////////////////////////////////////////////
// ///                                                    /// 
// ///       Deadlock Detection Scheme -svs, sriram      ///  
// ////////////////////////////////////////////////////////

// void Scheduler::printSet(std::set<int> aset, int pid)
// {
//   std::set<int>::iterator sit, sit_end;
//   sit_end = aset.end();
//   for(sit = aset.begin(); sit != aset.end(); sit++)
//     std::cout << *(new CB(pid, *sit)) <<std::endl;
// }

// std::set<int> Scheduler::computeSet_D1(std::set<int> aset, int index, CB from, CB to)
// {
//   std::set<int> retset;
  
//   std::set<int>::iterator sit, sit_end;
//   sit_end = aset.end();

//   for(sit = aset.begin(); *sit <= index; sit++ ) {
// 	retset.insert(*sit);
//   }
//   return retset;
  
// }


// std::set<int> Scheduler::computeSet_D2(int from, CB op)
// {
//   std::set<int> retset;
//   std::set<CB> CoI = coenabled_relation.findCoEnabledImage(op);
//   std::set<CB>::iterator coit, coit_end;
//   coit_end = CoI.end();
  
//   for(coit = CoI.begin(); coit != coit_end; coit++){
//     if((*coit)._pid == from){
//       retset.insert((*coit)._index);
      
//     }
//   }
  
//   return retset;
// }

// std::set<int> Scheduler::compute_D3(std::set<int> recv_set, int from, int notfrom)
// {
//   std::set<int> retset;
//     std::set<CB>tmp;
//   std::set<int>::iterator rit, rit_end;
//   rit_end = recv_set.end();
  
//   for(rit = recv_set.begin(); rit != rit_end; rit++){
//     CB c = *(new CB(from, *rit));
//     tmp = coenabled_relation.findCoEnabledImageNotFrom(c, notfrom);
//     for(std::set<CB>::iterator it1 = tmp.begin(); it1 != tmp.end(); it1++){
//       retset.insert((*it1)._pid);
//     }
//   }
  
//   return retset;
  
// }

// void Scheduler::computeSet_D2_D3_when_D1_isSend(std::set<int> D1, std::set<int> &D2, std::set<int> &D3, int index, int frompid, CB c)
// {
//   std::set<int>::iterator d1it;
  
//   for(d1it = D1.begin(); *d1it <= index; d1it++ ){
//     std::set<int> tmp = computeSet_D2(frompid, c);
//     for(std::set<int>::iterator sit = tmp.begin(); sit != tmp.end(); sit++)
//       D2.insert(*sit);
//   }

//   D3 = compute_D3(D2, frompid, c._pid);
// }

// void Scheduler::computeSet_D2_D3_when_D1_isRecv(std::set<int> D1, std::set<int> &D2, std::set<int> &D3, int index, int frompid, CB c)
// {
//   std::set<int>::iterator d1it;
  
//   for(d1it = D1.begin(); *d1it <= index; d1it++ ){
//     std::set<int> tmp = computeSet_D2(frompid, c);
//     for(std::set<int>::iterator sit = tmp.begin(); sit != tmp.end(); sit++)
//       D2.insert(*sit);
//   }
//   D3 = compute_D3(D1, frompid, c._pid);  
  
// }



  
// 1) for each wfr entry (a,b) : find the last wfr (c:pid(a), d:pid(b))
// 2) Compute Ancs*(b): only those targeting pid(a); 
// 3) Separate Ancs*(b) into : i) SendAncs*(b) (ii) RecvAncs*(b)
//
// 4) For SendAncs*(b) do
//     (i)   D1 = SendAncs*(b);
//     (ii)  D2 = compute CoI of SendAncs*(b): basically all recv call from pid(a) targeting pid(b) until (including) 'a'
//     (iii) D3 = compute the CoI of R(*)s in D2 other than the ones from pid(b)
//     (iv)  If diff=( |D1| - (|D2| - |D3|) > 0 => DEADLOCK : the orphaned send computation depends on the implementation
// 
// 5) For RecvAncs*(b) do 
//     (i)   D1 = RecvAncs*(b);
//     (ii)  D2 = compute CoI of D1 belonging to pid(a)
//     (iii) D3 = compute CoI of D1 NOT belonging to pid(a)
//     (iv)  if diff = |D1| - |D2| - |D3| > 0 => DEADLOCK : the orphaned recv is computation

        


// CB Scheduler::deadlockCheckWfR()
// {

//   WfRVecIterator wfrit, wfrit_end;
//   wfrit_end = waitfor_relation.wfr.end();

//   std::pair<CB, CB> lastwfr;
//   Node *nlast = it->_slist[it->_slist.size() -1];
 
//   for(wfrit = waitfor_relation.wfr.begin();
//       wfrit != wfrit_end; wfrit++){

    
//     // lastwfr = *wfrit;
//     lastwfr = waitfor_relation.getLastWfR(*wfrit); //line 1 a---->b
    
//     CB fromOp = lastwfr.first;
//     CB toOp = lastwfr.second;

   
//     // compute Ancs*(b)
//     std::set<int> allto_ancestors = getAllAncestorList(nlast, toOp);
//     allto_ancestors.insert(toOp._index);
    
//     std::set<int> all_SendAncs_Targeting_fromOp;
//     std::set<int> all_RecvAncs_Targeting_fromOp;
//     std::set<int>::iterator ait, ait_end;
//     ait_end = allto_ancestors.end();

//     //compute SendAncs*(b) and RecvAncs*(b) -- lines (2) and (3)
//     for(std::set<int>::iterator ait = allto_ancestors.begin(); ait != ait_end; ait++){
//       Envelope *env = nlast->GetTransition(toOp._pid, *ait)->GetEnvelope();
//       if (env->isRecvTypeOnly()){
// 	if(env->src_wildcard || env->src == fromOp._pid)
// 	  all_RecvAncs_Targeting_fromOp.insert(*ait);
//       }
//       else if (env->isSendType() && env->dest == fromOp._pid)
// 	all_SendAncs_Targeting_fromOp.insert(*ait);
//     }
    
//     allto_ancestors.clear();
    
//     ait_end = all_SendAncs_Targeting_fromOp.end();
//     for(ait = all_SendAncs_Targeting_fromOp.begin(); ait != ait_end; ait++){ //Line (4) - (i) to (iv)
      
//       std::set<int> D1 = computeSet_D1(all_SendAncs_Targeting_fromOp, *ait, fromOp, toOp);
//       std::set<int> D2;
//       std::set<int> D3; 
      
            
//       CB ancs_op_of_to (toOp._pid, *ait);
//       computeSet_D2_D3_when_D1_isSend (D1,D2,D3,*ait, fromOp._pid, ancs_op_of_to);

//       int diff = D1.size() - D2.size() + D3.size() ;
//       if(diff > 0) {
// 	return ancs_op_of_to;
//       }
//     }

//     ait_end = all_RecvAncs_Targeting_fromOp.end();
//     for(ait = all_RecvAncs_Targeting_fromOp.begin(); ait != ait_end; ait++){ //Line (5) - (i) to (iv)
      
//       std::set<int> D1 = computeSet_D1(all_RecvAncs_Targeting_fromOp, *ait, fromOp, toOp);
//       std::set<int> D2;
//       std::set<int> D3; 

//       CB ancs_op_of_to (toOp._pid, *ait);
//       std::cout << "ancs_op_of_to = "<< ancs_op_of_to << std::endl;
//       computeSet_D2_D3_when_D1_isRecv (D1,D2,D3, *ait, fromOp._pid, ancs_op_of_to);
//       int diff = D1.size() - D2.size() - D3.size();
//       std::cout << "diff " << diff <<std::endl;
//       if(diff > 0) {
// 	printSet(D1, toOp._pid);
// 	printSet(D2, fromOp._pid);
// 	std::cout << "Size of D3:" << D3.size() <<std::endl;
// 	return ancs_op_of_to;
//       }
//     }    
//     std::cout<<"================================="<<std::endl;
//   }
//   return *(new CB(-1, -1));
// }

// std::pair<CB, CB> Scheduler::deadlockCheckDet()
// {
  
//   std::vector<Node* >::iterator nit, nit_end;
//   nit_end = it->_slist.end();
//   CB cf, cb;
//   // iterate over nodes
//   for(nit = it->_slist.begin(); nit != nit_end; nit ++ ){
    
//     // Check if the curr_match-set at the node has deterministic recv
//     Node *ncurr = (*nit);
//     cb = ncurr->curr_match_set.back();
//     cf = ncurr->curr_match_set.front();
    
//     if(ncurr->curr_match_set.size() ==2){
//       Envelope *env = ncurr->GetTransition(cb)->GetEnvelope();
//       if( (env->func_id == IRECV || env->func_id == RECV) &&
// 	  !env->src_wildcard)
// 	{
	  
// 	  // find the CoI of the deterministic recv and its current match
// 	  std::set<CB> s1 = coenabled_relation.findCoEnabledImage(cb);
// 	  std::set<CB> s2 = coenabled_relation.findCoEnabledImage(cf);
// 	  if(s1.size() != s2.size())
// 	    return (std::pair<CB, CB> (cf, cb));
// 	}
//     }
//   }
//   cb._pid = -1;
//   cb._index = -1;
//   cf._pid = -1;
//   cf._index = -1;
  
//   return (std::pair<CB, CB> (cf, cb));
// }



// void Scheduler::deadlockDetection()
// {
//   int flag = -1;
//   CB res;
//   std::pair<CB, CB> c;
//   c =  deadlockCheckDet();
//   res = deadlockCheckWfR();
    
//   if( ! (res._pid == -1)) flag = 0;
//   //     suggestErrorTraceWfR(c);
  
//   //  c =  deadlockCheckDet();
//   if(!(c.first._pid == -1) && !(c.second._pid == -1) ) flag = 1;
//   //     suggestErrorTraceDet(c);
  
//   if(flag == 1)
//     std::cout << "DETECTED DEADLOCK!!:" << c.first << c.second <<std::endl;
//   if(flag == 0)
//      std::cout << "DETECTED DEADLOCK!!:" << res <<std::endl;
// }

// End of symmetry code 

Scheduler * Scheduler::GetInstance () {

  assert (_param_set);

  /*
   * If Instance is already created, just return it.
   */
  if (_instance != NULL) {
    return _instance;
  }
  _instance = new Scheduler ();
  if (_errorno != 0) {
    delete _instance;
    exit (_errorno);
  }
  return _instance;
}

void Scheduler::SetParams (std::string port, std::string num_clients,
                           std::string server, bool send_block,
                           std::string fname, std::string logfile,
                           std::vector<std::string> fargs,
                           bool mpicalls, bool verbose, bool quiet,
                           bool unix_sockets, int report_progress,
                           bool fib, bool openmp, bool env_only,
                           bool batch_mode, bool stop_at_deadlock,
                           te_Exp_Mode explore_mode, int explore_some,
                           std::vector<int> *explore_all,
                           std::vector<int> *explore_random,
                           std::vector<int> *explore_left_most,
                           bool debug, bool no_ample_set_fix,
                           unsigned bound, bool limit_output
			   /* == fprs start == */
			   , bool fprs
			   /* == fprs end == */
			   ) {//CGD

  _param_set = true;
  _port = port;
  _num_procs = num_clients;
  _server = server;
  _send_block = send_block;
  _fname = fname;
  _fargs = fargs;
  _mpicalls = mpicalls;
  _verbose = verbose;
  _quiet = quiet;
  _unix_sockets = unix_sockets;
  _report_progress = report_progress;
  _fib = fib;
  _openmp = openmp;
  _env_only = env_only;
  _batch_mode = batch_mode;
  _stop_at_deadlock = stop_at_deadlock;
  _explore_mode = explore_mode; 
  _explore_some = explore_some;
  _explore_all = explore_all;
  _explore_random = explore_random;
  _explore_left_most = explore_left_most;
  _debug = debug;
  _no_ample_set_fix = no_ample_set_fix;
  _bound = bound;
  _limit_output = limit_output;//CGD
  /* == fprs start == */
  _fprs = fprs;
  /* == fprs end == */

  /* open the logfile for writing */    
  _logfile.open (logfile.c_str());
  if (logfile != "" && ! _logfile.is_open()) {
    if (!quiet) {
      std::cout << "Unable to open file " << logfile << "\n";
    }
    exit (20);
  } else {
    _logfile << num_clients << "\n";
  }
}

Scheduler::Scheduler () :
  ServerSocket (atoi(_port.c_str()),atoi(_num_procs.c_str()),
		_unix_sockets, _batch_mode), order_id(1) {

  _errorno = Start ();
  if (_errorno != 0) {
    if (!_quiet) {
      switch (_errorno) {
      case 13:
	std::cout << "Server unable to open Socket!\n";
	break;
      case 14:
	std::cout << "Server unable to bind to port. The port may already be in use.\n";
	break;
      case 15:
	std::cout << "Server unable to listen on the socket\n";
	break;
      }
    }
    return;
  }

  StartClients ();

  _errorno = Accept ();
  if (_errorno != 0) {
    if (!_quiet) {
      switch (_errorno) {
      case 16:
	std::cout << "Server unable to accept\n";
	break;
      case 17:
	std::cout << "Error reading from socket in server\n";
	break;
      }
    }
    return;
  }

  FD_ZERO (&_fds);
  _lfd = 0;
  for (int i = 0 ; i < atoi (_num_procs.c_str ()); i++) {
    SOCKET fd = GetFD (i);
    FD_SET (fd, &_fds);
    _fd_id_map[fd] = i;
    if (fd > _lfd) {
      _lfd = fd;
    }
  }

  it  = new ITree ( new Node (atoi(_num_procs.c_str ())), ProgName());
  m = new M();
  w = new W();
  /*
   * Intially all processes are ready to run. Add
   * all procs to the list.
   */

  for (int i = 0 ; i < atoi (_num_procs.c_str ()); i++) {
    _runQ.push_back (new MpiProc (i));
  }

  /* == fprs bedin == */
  it->_is_exall_mode = (bool*) malloc(sizeof(bool)*atoi(_num_procs.c_str()));
  for (int i = 0 ; i < atoi(_num_procs.c_str()) ; i++) it->_is_exall_mode[i] = false;
  /* == fprs end == */
}

std::string Scheduler::ProgName () {

  std::string::size_type pos = _fname.find_last_of ("/", _fname.size ()-1);
  if (pos == std::string::npos) {
    return _fname;
  }
  return _fname.substr (pos+1, _fname.size ()-1);
}

void Scheduler::StartClients () {
  std::vector<const char *> cmd;

  interleavings++;
  const char *use_mpirun_env = getenv("USE_MPIRUN");
  bool use_mpirun = use_mpirun_env && !strcmp(use_mpirun_env, "true");

  if (_batch_mode) {
    std::cout << "Please launch the clients on the cluster with the following command:" << std::endl;
    if (use_mpirun) {
      std::cout << "    mpirun ";
    } else {
      std::cout << "    mpiexec ";
    }
    std::cout << "-n " << _num_procs << " "
	      << "\"" << _fname << "\" "
	      << "0 "
	      << _port << " "
	      << _num_procs << " "
	      << _server << " "
	      << (_send_block ? "1" : "0") << " ";
    for (int i = 0; i < int(_fargs.size()); i++) {
      std::cout << _fargs[i] << " ";
    }
    std::cout << std::endl;
    return;
  }

  if (use_mpirun) {
    cmd.push_back("mpirun");
  } else {
    cmd.push_back("mpiexec");
  }
  cmd.push_back("-n");
  cmd.push_back((const char *)_num_procs.c_str());

  if (_env_only) {
    cmd.push_back("-env");
    cmd.push_back("ISP_USE_ENV");
    cmd.push_back("1");
    cmd.push_back("-env");
    cmd.push_back("ISP_HOSTNAME");
#ifndef WIN32
    if (_unix_sockets) {
      cmd.push_back((const char *)GetSocketFile ().c_str());
      cmd.push_back("-env");
      cmd.push_back("ISP_UNIX_SOCKETS");
      cmd.push_back("1");
    }
    else
#endif
      {
	cmd.push_back((const char *)_server.c_str());
	cmd.push_back("-env");
	cmd.push_back("ISP_UNIX_SOCKETS");
	cmd.push_back("0");
	cmd.push_back("-env");
	cmd.push_back("ISP_PORT");
	cmd.push_back((const char *)_port.c_str());
      }
    cmd.push_back("-env");
    cmd.push_back("ISP_NUMPROCS");
    cmd.push_back((const char *)_num_procs.c_str());
    cmd.push_back("-env");
    cmd.push_back("ISP_SENDBLOCK");
    cmd.push_back(_send_block ? "1" : "0");
  }

  cmd.push_back((const char *)_fname.c_str());
  if (!_env_only) {
#ifndef WIN32
    if (_unix_sockets) {
      cmd.push_back("1");
      cmd.push_back(GetSocketFile ().c_str());
    }
    else
#endif
      {
	cmd.push_back("0");
	cmd.push_back((const char *)_port.c_str());
      }
    cmd.push_back((const char *)_num_procs.c_str());
    cmd.push_back((const char *)_server.c_str());
    cmd.push_back(_send_block ? "1" : "0");

    std::stringstream ss_interleaving;
    ss_interleaving << interleavings;
    cmd.push_back(ss_interleaving.str().c_str());
  }

  for (int i = 0; i < int(_fargs.size()); i++) {
    cmd.push_back((const char *)_fargs[i].c_str());
  }
  cmd.push_back(NULL);

#ifndef WIN32
  int gpid = fork ();
  /*
   * Child process must now exec
   */
  if (gpid == 0) {
    if (execvp (cmd[0], (char* const*) &cmd[0]) < 0) {
      cmd[0] = "mpirun";
      if (execvp (cmd[0], (char* const*) &cmd[0]) < 0) {
	if (!_quiet) {
	  std::cout <<"Unable to Start Clients using exec!\n";
	}
	exit (12);
      }
    }
  } else if (gpid < 0) {
    perror(0);
    exit(1);
  }
  _pid = gpid;
#else
  std::string filename("\"" + _fname + "\"");
  DWORD execvp(const char *file, char const **argv);
  if ((_pid = execvp (NULL, &cmd[0])) == 0) {
    if (!_quiet) {
      std::cout <<"Unable to Start Clients using exec!\n";
    }
    exit (12);
  }
#endif

  if (!_quiet && !_limit_output) {//CGD
    std::cout << "Started Process: " << _pid << std::endl;
  }
}

int Scheduler::Restart () {
  int result;
    
  ServerSocket::Restart ();
  StartClients ();
  if ((result = Accept ()) != 0) {
    if (!_quiet) {
      switch (result) {
      case 16:
	std::cout << "Server unable to accept\n";
	break;
      case 17:
	std::cout << "Error reading from socket in server\n";
	break;
      }
    }
    exit (result);
  }
  for (int i = 0 ; i < atoi (_num_procs.c_str ()); i++) {
    _runQ[i]->_read_next_env = true;
    /* == fprs begin == */
    it->_is_exall_mode[i] = false;
    /* == fprs end == */
  }

  it->ResetMatchingInfo();

  return 0;
}
void PrintStats (unsigned long total_time) {
  
  std::cout << "Total time = " << 
    (1.0* total_time)/1000000 << "sec \n";
	

}

unsigned long long getTimeElapsed (struct timeval first, 
				   struct timeval second) {
  unsigned long long secs;
  unsigned long long usecs = 0;

  if (first.tv_usec > second.tv_usec) {
    usecs = 1000000 - first.tv_usec + second.tv_usec;
    second.tv_sec--;
  } else {
    usecs = second.tv_usec - first.tv_usec;
  }
  secs = (second.tv_sec - first.tv_sec);
  secs *= 1000000;
  return (secs + usecs);
}
void Scheduler::StartMC () {
  struct timeval		  first;  //performance
  struct timeval		  second;		//performance	
  unsigned long total_time = 0;
  
  /*
   * First generate one single interleaving.
   * Use timeouts for this incase the processes
   * have deadlocked!
   */
  /* == fprs begin == */
  unsigned ran_seed = time(0);
  /* == fprs end == */
  for (;;) {
    gettimeofday (&first, NULL); //performance
    if (!_quiet) {
      std::cout << "INTERLEAVING :" << interleavings << "\n";
      fflush(stdout);
    }
    /* == fprs begin == */
    if (Scheduler::_fprs) {
      srand(ran_seed);
      Scheduler::_explore_mode = EXP_MODE_RANDOM;
    }
    /* == fprs end == */
    generateFirstInterleaving ();

    // modification for CoE -- svs, sriram 
    m->_MConstruct(it);
    
    //std::cout << "Match relation:" << *m << std::endl;
    //std::cout << "Match relation size:" << m->_MSet.size() << std::endl;
    w->MPtr = m;
    w->_WConstruct(it);
    //std::cout << "Wait relation:" << *w << std::endl;

    // waitfor_relation.coenabledPtr = &coenabled_relation;
    // waitfor_relation.WfRConstruct(it);
    //  std::cout << "Wait-for relation:" << waitfor_relation << std::endl;

    w->TransitiveClosure(it->_slist[it->_slist.size()-1]);
    //std::cout << "Wait relation after transitive closure:" << *w << std::endl;

    w->RefineW();
    //std::cout << "Wait relation after refinement:" << *w << std::endl;
    //std::cout.flush();
    
    w->ApplyRefineRuleOne(it->_slist[it->_slist.size()-1]);
    
    std::cout << "Match relation after refinement rule 1:" << *m << std::endl;
    std::cout << "Wait relation after refinement rule 1:" << *w << std::endl;
    std::cout.flush();
    
    //    w->ApplyRefineRuleTwo(it->_slist[it->_slist.size()-1]);
    
    // std::cout << "Match relation after refinement rule 1:" << *m << std::endl;
    // std::cout << "Wait relation after refinement rule 1:" << *w << std::endl;
    // std::cout.flush();
    


    // while(ApplyRefineRuleOne()) {
    //     waitfor_relation.WfRConstruct(it);
    // 	std::cout << "After Refine Rule [1] : \n\n"; 
    // 	std::cout << "Co-enable relation:" << coenabled_relation << std::endl;
	
    // 	//waitfor_relation.transitiveClosure();
    // }

    // std::cout << "After Refine Rule [1] : \n\n"; 
    // std::cout << "Co-enable relation:" << coenabled_relation << std::endl;
    // std::cout << "Wait-for relation:" << waitfor_relation << std::endl;
    
    
    // std::cout.flush();
    
    //w->DeadlockDetection(it->al_curr, it->_slist[it->_slist.size()-1]);
    
    exit(0);


    //ExitMpiProcessAndWait (true);
    // std::cin.get();
	
    // end of modification --svs, sriram 

    /* == fprs begin == */
    if (Scheduler::_fprs) {
      Scheduler::_explore_mode = EXP_MODE_ALL;
    }
    /* == wfchiag end == */
#ifdef FIB
    if (_fib) {
      it->findInterCB ();
      it->FindRelBarriers ();
    }
#endif
    it->GetCurrNode ()->PrintLog ();
        
    //CGD print Mismatched Types
    /* == fprs start == */
    if (_fprs == false) {
      //it->printTypeMismatches();
    }
    /* == fprs end == */

    if (Scheduler::_just_dead_lock) {
      Scheduler::_logfile << Scheduler::interleavings << " DEADLOCK\n";
      Scheduler::_just_dead_lock = false;
      Scheduler::_deadlock_found = true;
    }        
    bool outputused = false;
    std::stringstream outputmsg;
    outputmsg << "-----------------------------------------" << std::endl;
    if (_verbose) {
      outputmsg << *(it->GetCurrNode ());
      outputused = true;
    } else if (!_quiet && !_limit_output) {//CGD
      std::vector<TransitionList *>::iterator iter, iter_end;
      iter = it->GetCurrNode ()->_tlist.begin ();
      iter_end = it->GetCurrNode ()->_tlist.end ();
      for (; iter != iter_end; iter++) {
	bool output = false;
	if ((*iter)->_leaks_count != 0) {
	  output = true;
	  outputmsg << "Rank " << (*iter)->GetId () << ": ";
	  outputmsg << (*iter)->_leaks_count << " resource leaks detected.";
	}
	if (_mpicalls) {
	  if (!false) {
	    outputmsg << "Rank " << (*iter)->GetId () << ": ";
	    output = true;
	  }
	  outputmsg << (*iter)->_tlist.size () << " MPI calls trapped.";
	}
	if (output) {
	  outputmsg << std::endl;
	}
	outputused = outputused || output;
      }
    }
    gettimeofday (&second, NULL);
    total_time += getTimeElapsed (first, second);
    if (it->NextInterleaving ()) {
      if (Scheduler::_deadlock_found && Scheduler::_stop_at_deadlock) {
	std::cout << "Verification stopped. There are still more interleavings to explore\n";
	std::cout << "To continue exploring, please re-run and do not set stop-at-deadlock flag\n";
	ExitMpiProcessAndWait(true);
	exit(1);
      }
      if (outputused) {
	outputmsg << "-----------------------------------------" << std::endl;
	std::cout << outputmsg.str();
      }
      it->resetDepth();
#ifdef FIB
      if (_fib) {
	/*
	 * At the start of next interleaving clear the taken ample moves
	 * in the previous interleaving.
	 */
	it->al_curr.clear();
      }
#endif

      Restart ();

      //    std::cout << "THERE ARE MORE INTERLEAVINGS!!!\n";
    } else {
      ExitMpiProcessAndWait (true);
      if (!_quiet && !_limit_output) {//CGD
	std::string explore_mode = "";
	if (Scheduler::_explore_mode == EXP_MODE_ALL)
	  explore_mode = "All Relevant Interleavings";
	else if (Scheduler::_explore_mode == EXP_MODE_RANDOM)
	  explore_mode = "Random Choice";
	else if (Scheduler::_explore_mode == EXP_MODE_LEFT_MOST)
	  explore_mode = "First Available Choice";

	if (Scheduler::_deadlock_found) 
	  outputmsg << "ISP detected deadlock!!!" << std::endl;
	else
	  outputmsg << "ISP detected no deadlocks!" << std::endl;

	outputmsg << "Total Explored Interleavings: " << interleavings << std::endl;                
	outputmsg << "Interleaving Exploration Mode: " << explore_mode << std::endl;
	outputmsg << "-----------------------------------------" << std::endl;
	std::cout << outputmsg.str();
      }
#ifdef FIB
      if (_fib) {
	it->printRelBarriers ();
      }
      delete it->last_node;
#endif

      PrintStats(total_time);
      return;
    }
  }
}

void Scheduler::generateFirstInterleaving () {
  struct timeval tv;
  Transition *t;
  tv.tv_usec = 0;
  tv.tv_sec = 2;
  int count = atoi(_num_procs.c_str ());
  int nprocs = count;

  while (count) {

    for (int  i = 0 ; i < nprocs; i++) {
      if (_runQ[i]->_read_next_env) {
                
	t = getTransition(i);
	/* == fprs begin == */    
	// IMPORTANT NOTE: the constant ISP_START_SAMPLING and ISP_END_SAMPLEING here should be corresponded to the ISP_START_SAMPLING and ISP_END_SAMPLING defined in isp.h
	if (_fprs) {        
	  if (t->GetEnvelope()->func_id == PCONTROL && t->GetEnvelope()->stag == ISP_START_SAMPLING) {
	    it->_is_exall_mode[i] = true;
	  }
	  if (t->GetEnvelope()->func_id == PCONTROL && t->GetEnvelope()->stag == ISP_END_SAMPLING) {
	    it->_is_exall_mode[i] = false;
	  }
	}
	/* == fprs end == */
	//DS( std::cout << " [generateFirstInterleaving 1] e=" << t->GetEnvelope() << " e->func_id=" << t->GetEnvelope()->func_id << "\n"; )
	if (!(it->GetCurrNode ())->_tlist[i]->AddTransition (t)) {
	  ExitMpiProcessAndWait (true);

	  if (!Scheduler::_quiet) {
	    /* ISP expects the same transitions on restart
	     * to ensure the correctness of DPOR
	     * backtracking - If the program changes its
	     * control flow path upon restarting, ISP will
	     * not work */
	    std::cout << "ERROR! TRANSITIONS ON RESTARTS NOT SAME!!!!\n";
	  }
	  exit (21);
	}

	//DS( std::cout << " [generateFirstInterleaving 2] e=" << t->GetEnvelope() << " e->func_id=" << t->GetEnvelope()->func_id << "\n"; )

	/* Some memory leak can happen here if we're not in
	   the first interleaving. T has a "NEW" envelope
	   which is never freed When this leak is fixed,
	   please remove this comment */
	if (! t->GetEnvelope ()->isBlockingType ()) {
	  Send (i, goback);
	} else {
	  _runQ[i]->_read_next_env = false;
	}
	if (t->GetEnvelope ()->func_id == FINALIZE) {
	  //std::cout << "setting no more read for " << i <<
	  //"\n";
	  _runQ[i]->_read_next_env = false;
	  count--;
	}
	delete t;
      }
    }
    std::list <int> l;
    std::list <int>::iterator iter;
    std::list <int>::iterator iter_end;
    //[grz] would and 'if' be enough here?
    while (!hasMoreEnvelopeToRead ()) {
      if (it->CHECK (*this, l) == 1)
	return;
      iter_end = l.end();

      /* This takes advantage of the fact that if we have
	 PROBE/IPROBE, the size of l has to be less than 2, in
	 which the first one is the send, the second one is the
	 PROBE/IPROBE */
      /* In the case of PROBE/IPROBE, the iprobe call is the
	 only call that should be allowed to go ahead */
      if (Scheduler::_probed) {
	assert (l.size() <= 2);
	_runQ[l.back()]->_read_next_env = true;
	Scheduler::_probed = false;
      } else {
	for (iter = l.begin (); iter != iter_end; iter++) {
	  _runQ[*iter]->_read_next_env = true;
                    
	}
      }
    }

  }
  // Reached and of interleaving without any deadlocks - update InterCB
#ifdef CONFIG_OPTIONAL_AMPLE_SET_FIX
  if(!Scheduler::_no_ample_set_fix)
#endif
    it->ProcessInterleaving();
}

bool Scheduler::hasMoreEnvelopeToRead () {

  for (int  i = 0 ; i < atoi (_num_procs.c_str ()); i++) {
    if (_runQ[i]->_read_next_env) {
      return true;
    }
  }
  return false;
}

Transition *Scheduler::getTransition (int id) {

  Envelope *e = NULL;
  char    buffer[BUFFER_SIZE];
   
  do { 
    memset(buffer, '\0', BUFFER_SIZE);
    Receive (id, buffer, BUFFER_SIZE);

    /* == fprs start == */
    e = CreateEnvelope (buffer, id, order_id++, it->_is_exall_mode[id]);
    /* == fprs end == */
    if (!e) {
      it->GetCurrNode ()->PrintLog ();
      ExitMpiProcessAndWait (true);
      if (!_quiet) {
	std::cout << *(it->GetCurrNode ()) << "\n";
	std::cout << "Receiving empty buffer - Terminating ...\n";
      }
      exit (22);
    }
    //DS( std::cout << " [getTransition] e=" << e << " e->func_id=" << e->func_id << "\n"; )
    if (e->func_id == LEAK) {
      std::stringstream& leaks = it->GetCurrNode ()->_tlist[id]->_leaks_string;
      it->GetCurrNode ()->_tlist[id]->_leaks_count++;
      leaks << Scheduler::interleavings << " " << id << " Leak ";
      leaks << e->display_name << " { } { } Match: -1 -1 File: ";
      leaks << e->filename.length () << " " << e->filename << " " << e->linenumber << std::endl;
      Send (id, goback);
      order_id--;
    }
  } while (e->func_id == LEAK);

  bool error = false;
  switch (e->func_id) {

  case ASSERT:
    it->GetCurrNode ()->PrintLog ();
    _logfile << interleavings << " "
	     << e->id << " "
	     << "ASSERT "
	     << "Message: " << e->display_name.length() << " " << e->display_name << " "
	     << "Function: " << e->func.length() << " " << e->func << " "
	     << "File: " << e->filename.length() << " " << e->filename << " " << e->linenumber << "\n";
    ExitMpiProcessAndWait (true);
    if (!_quiet) {
      std::cout << "-----------------------------------------" << std::endl;
      std::cout << *(it->GetCurrNode ()) << std::endl;
      std::cout << "Program assertion failed!" << std::endl;
      std::cout << "Rank " << e->id << ": " << e->filename << ":" << e->linenumber
		<< ": " << e->func << ": " << e->display_name << std::endl;
      std::cout << "Killing program " << ProgName() << std::endl;
      std::cout << "-----------------------------------------" << std::endl;
      std::cout.flush();
    }
    exit (3);
    break;

  case ABORT:
    it->GetCurrNode()->_tlist[id]->AddTransition(new Transition(e));
    it->GetCurrNode ()->PrintLog ();
    ExitMpiProcessAndWait (true);
    if (!_quiet) {
      std::cout << "-----------------------------------------" << std::endl;
      std::cout << *(it->GetCurrNode ()) << std::endl;
      std::cout << "MPI_Abort on rank " << e->id << " caused abort on all ranks." << std::endl;
      std::cout << "Killing program " << ProgName() << std::endl;
      std::cout << "-----------------------------------------" << std::endl;
      std::cout.flush();
    }
    exit (4);
    break;

  case SEND:
  case ISEND:
  case SSEND:
  case RSEND:
    if (!e->dest_wildcard &&
	(e->dest < 0 || e->dest >= atoi (_num_procs.c_str ()))) {
      error = true;
    }
    break;
  case IRECV:
  case IPROBE:
  case PROBE:
  case RECV:
    if (!e->src_wildcard &&
	(e->src < 0 || e->src >= atoi (_num_procs.c_str ()))) {
      error = true;
    }
    break;
  case SCATTER:
  case GATHER:
  case SCATTERV:
  case GATHERV:
  case BCAST:
  case REDUCE:
    if (e->count < 0 || e->count >= atoi (_num_procs.c_str ())) {
      error = true;
    }
    break;
  }
  if (error) {
    it->GetCurrNode ()->_tlist[id]->AddTransition(new Transition(e));
    it->GetCurrNode ()->PrintLog ();
    ExitMpiProcessAndWait (true);
    if (!_quiet) {
      std::cout << "-----------------------------------------" << std::endl;
      std::cout << *(it->GetCurrNode ()) << std::endl;
      std::cout << "Rank " << id << ": " << "Invalid rank in MPI_" << e->func << " at "
		<< e->filename << ":" << e->linenumber << std::endl;
      std::cout << "Killing program " << ProgName() << std::endl;
      std::cout << "-----------------------------------------" << std::endl;
      std::cout.flush();
    }
    exit (5);
  }

    return new Transition(e);
}
